param (
    [string]$Action,
    [string]$DacpacPath,
    [string]$PublishProfilePath = "",
    [string]$ServerInstance,
    [string]$DatabaseName,
    [string]$UserName,
    [string]$Password,
    [string]$SqlPackagePath,
    [string]$OutputPath = "",
    [string]$UseMultiSubnetFailover,
    [string]$SQLPackageDeployProperties,
    [string]$SQLCmdVariables = "",
    [string]$SQLPackageParameters = ""
)

$ErrorActionPreference = "Stop"
Write-Host "Script started. Action: $Action"

Write-Host "RAW SqlCmdVariables Value: $SQLCmdVariables"

# --- Helper Functions ---

function Format-SqlCmdVariables {
    [CmdletBinding()]
    param (
        [AllowNull()][Parameter(Mandatory=$true)][hashtable]$SqlCmdVariables
    )
    trap { throw $_ }

    $result = @()
    if ($SqlCmdVariables -ne $null) {
        foreach ($variable in $SqlCmdVariables.GetEnumerator()) {
            $result += "/v:$($variable.Name)=$($variable.Value)"
        }
    }
    return $result
}

function Format-SqlPackageParameters {
    [CmdletBinding()]
    param (
        [AllowNull()][Parameter(Mandatory=$true)][hashtable]$Parameters
    )
    trap { throw $_ }

    $result = @()
    if ($Parameters -ne $null) {
        foreach ($variable in $Parameters.GetEnumerator()) {
            if (($variable.Value -is [int]) -or ($variable.Value -is [bool])) {
                $result += "/$($variable.Name):$($variable.Value)"
            } else {
                $result += "/$($variable.Name):'$($variable.Value)'"
            }
        }
    }
    return $result
}

function Format-SqlPackageProperties {
    [CmdletBinding()]
    param (
        [AllowNull()][Parameter(Mandatory=$true)][hashtable]$Properties
    )
    trap { throw $_ }

    $result = @()
    if ($Properties -ne $null) {
        foreach ($variable in $Properties.GetEnumerator()) {
            if (($variable.Value -is [int]) -or ($variable.Value -is [bool])) {
                $result += "/p:$($variable.Name)=$($variable.Value)"
            } else {
                $result += "/p:$($variable.Name)='$($variable.Value)'"
            }
        }
    }
    return $result
}

# --- Main Script Logic ---

# Validate sqlpackage.exe path
if (-not (Test-Path $SqlPackagePath)) {
    throw "sqlpackage.exe not found at: $SqlPackagePath"
}

# Ensure Output folder exists
if ($OutputPath -ne "") {
    $folder = Split-Path -Path $OutputPath -Parent
    if (-not (Test-Path $folder)) {
        Write-Host "Creating output directory: $folder"
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# Build Connection String
$ConnectionString = "Server=$ServerInstance;Database=$DatabaseName;User=$UserName;Password=$Password;Encrypt=True;TrustServerCertificate=True;"
if ($UseMultiSubnetFailover) {
    $ConnectionString += "multisubnetfailover=true;"
}

# --- Parse Inputs ---

$null = $sqlCmdVariableCollection = @{}
$null = $sqlPackageParameterCollection = @{}
$null = $sqlPackagePropertyCollection = @{}
$rawSqlPackageDeployProperty = ""

# SQLCmdVariables
if (![string]::IsNullOrWhiteSpace($SQLCmdVariables)) {
    try {
        $sqlCmdVariableCollection = ConvertFrom-Json $SQLCmdVariables
        Write-Host "Parsed SqlCmdVariables successfully."
    } catch {
        Write-Warning "Failed to parse SqlCmdVariables. Skipping."
    }
} else {
    Write-Host "SqlCmdVariables is empty."
}

# SQLPackageParameters
if (![string]::IsNullOrWhiteSpace($SQLPackageParameters)) {
    try {
        $sqlPackageParameterCollection = ConvertFrom-Json $SQLPackageParameters
        Write-Host "Parsed SqlPackageParameters successfully."
    } catch {
        Write-Warning "Failed to parse SQLPackageParameters. Skipping."
    }
} else {
    Write-Host "SqlPackageParameters is empty."
}

# SQLPackageDeployProperties
if (![string]::IsNullOrWhiteSpace($SQLPackageDeployProperties)) {
    try {
        $sqlPackagePropertyCollection = ConvertFrom-Json $SQLPackageDeployProperties
        Write-Host "Parsed SQLPackageDeployProperties successfully."
    } catch {
        Write-Warning "Failed to parse SQLPackageDeployProperties. Falling back to raw string."
        $rawSqlPackageDeployProperty = $SQLPackageDeployProperties
    }
} else {
    Write-Host "SQLPackageDeployProperties is empty."
}

# --- Build the sqlpackage.exe Parameter Array ---

$params = @()

$params += "/Action:$Action"

if (![string]::IsNullOrWhiteSpace($PublishProfilePath)) {
    $params += "/Profile:$PublishProfilePath"
}

if ($Action -eq 'Extract') {
    $params += "/TargetFile:$DacpacPath"
} else {
    $params += "/SourceFile:$DacpacPath"
}

if (![string]::IsNullOrWhiteSpace($ConnectionString)) {
    if ($Action -eq 'Extract') {
        $params += "/SourceConnectionString:$ConnectionString"
    } else {
        $params += "/TargetConnectionString:$ConnectionString"
    }
}

if (($Action -eq 'Script' -or $Action -eq 'DeployReport') -and (![string]::IsNullOrWhiteSpace($OutputPath))) {
    $params += "/OutputPath:$OutputPath"
}

# Now add the parsed and formatted variables
$params += Format-SqlCmdVariables -SqlCmdVariables $sqlCmdVariableCollection
$params += Format-SqlPackageProperties -Properties $sqlPackagePropertyCollection
$params += Format-SqlPackageParameters -Parameters $sqlPackageParameterCollection

# If raw property fallback exists
if (![string]::IsNullOrWhiteSpace($rawSqlPackageDeployProperty)) {
    $params += "/p:$rawSqlPackageDeployProperty"
}

# --- Print the full sqlpackage.exe command (one line) ---

$cmdString = "& `"$SqlPackagePath`" " + ($params -join " ")
Write-Host ""
Write-Host "Executing full sqlpackage.exe command: $cmdString"
Write-Host ""

# --- Execute with Retry ---

$maxRetries = 3
$retryDelaySeconds = 5
$attempt = 1
$success = $false

while ($attempt -le $maxRetries -and -not $success) {
    Write-Host "Attempt ${attempt} of ${maxRetries}: Running sqlpackage.exe..."
    try {
        & $SqlPackagePath @params
        if ($LASTEXITCODE -eq 0) {
            $success = $true
            Write-Host "sqlpackage executed successfully on attempt $attempt"
        } else {
            throw "sqlpackage failed with exit code $LASTEXITCODE"
        }
    } catch {
        Write-Warning "sqlpackage failed on attempt ${attempt}: $_"
        if ($attempt -lt $maxRetries) {
            Write-Host "Retrying in $retryDelaySeconds seconds..."
            Start-Sleep -Seconds $retryDelaySeconds
        } else {
            throw "sqlpackage failed after $maxRetries attempts."
        }
    }
    $attempt++
}

Write-Host "Script completed successfully"


    - name: DeployReport DACPAC
      id: deploy-report
      uses: ./.github/actions/sql-dacpac-deployer
      with:
        Action: "DeployReport"
        DacpacPath: "${{ github.workspace }}\\packages\\Employee.Invitation.Database.Build.dacpac"
        DatabaseName: "${{ env.DB_NAME }}"
        UserName: "${{ env.SQL_USER_NAME }}"
        SqlPackagePath: "${{ env.SQLPACKAGE_DIR }}\\sqlpackage.exe"
        sql-password-parameter-store: "${{ env.SQL_PASSWORD_PARAMETER_STORE }}"
        ArtifactDownloadPath: "${{ github.workspace }}\\dacpacs"
        ReleaseNumber: "${{ env.RELEASE_NUMBER }}"
        EnvironmentName: "${{ env.DACPAC_ENVIRONMENT }}"
        FileName: "deployreport.xml"
        TargetServer: ${{ env.TARGET_SERVERS }}
        PublishProfileFilePath: "${{ github.workspace }}\\packages\\${{ env.PUBLISH_PROFILE_FILE_NAME }}"
        UseMultiSubnetFailover: ${{ env.MULTI_SUBNET_FAILOVER }}
        SQLPackageDeployProperties: ${{ env.SQL_PACKAGE_DEPLOY_PROPERTIES }}
        # SQLCMDVariables: ""
        SQLCMDVariables: '${{ env.SQL_CMD_VARIABLES }}'
        SQLPackageParameters: ${{ env.SQL_PACKAGE_PARAMETERS }}
