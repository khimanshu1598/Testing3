param (
    [string]$Action,
    [string]$DacpacPath,
    [string]$PublishProfilePath = "",
    [string]$ServerInstance,
    [string]$DatabaseName,
    [string]$UserName,
    [string]$Password,
    [string]$SqlPackagePath,
    [string]$OutputPath = "",
    [string]$UseMultiSubnetFailover,
    [string]$SQLPackageDeployProperties,
    [string]$SQLCmdVariables = "",
    [string]$SQLPackageParameters = ""
)

$ErrorActionPreference = "Stop"
Write-Host "Script started. Action: $Action"

# Helper functions
function Format-SqlCmdVariables {
    param ([hashtable]$SqlCmdVariables)
    $result = @()
    if ($SqlCmdVariables) {
        foreach ($kv in $SqlCmdVariables.GetEnumerator()) {
            $result += "/v:$($kv.Key)='$($kv.Value)'"
        }
    }
    return $result
}

function Format-SqlPackageParameters {
    param ([hashtable]$SqlPackageParameters)
    $result = @()
    if ($SqlPackageParameters) {
        foreach ($kv in $SqlPackageParameters.GetEnumerator()) {
            $result += "/p:$($kv.Key)='$($kv.Value)'"
        }
    }
    return $result
}

function Format-SqlPackageProperties {
    param ([hashtable]$SqlPackageProperties)
    $result = @()
    if ($SqlPackageProperties) {
        foreach ($kv in $SqlPackageProperties.GetEnumerator()) {
            $result += "/p:$($kv.Key)='$($kv.Value)'"
        }
    }
    return $result
}

# Validate sqlpackage.exe
if (-not (Test-Path $SqlPackagePath)) {
    throw "sqlpackage.exe not found at: $SqlPackagePath"
}

# Ensure output folder exists
if ($OutputPath -ne "") {
    $folder = Split-Path -Path $OutputPath -Parent
    if (-not (Test-Path $folder)) {
        Write-Host "Creating output directory: $folder"
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# Build connection string
$ConnectionString = "Server=$ServerInstance;Database=$DatabaseName;User=$UserName;Password=$Password;Encrypt=True;TrustServerCertificate=True;"
if ($UseMultiSubnetFailover) { $ConnectionString += "multisubnetfailover=true;" }

# Parse JSON inputs
$sqlCmdVariableCollection = @{}
$sqlPackageParameterCollection = @{}
$sqlPackagePropertyCollection = @{}

if (![string]::IsNullOrWhiteSpace($SQLCmdVariables)) {
    try {
        $sqlCmdVariableCollection = ConvertFrom-Json $SQLCmdVariables
        Write-Host "Parsed SqlCmdVariables successfully."
    } catch {
        Write-Warning "Failed to parse SqlCmdVariables. Skipping."
    }
} else {
    Write-Host "SqlCmdVariables is empty."
}

if (![string]::IsNullOrWhiteSpace($SQLPackageParameters)) {
    try {
        $sqlPackageParameterCollection = ConvertFrom-Json $SQLPackageParameters
        Write-Host "Parsed SqlPackageParameters successfully."
    } catch {
        Write-Warning "Failed to parse SqlPackageParameters. Skipping."
    }
} else {
    Write-Host "SqlPackageParameters is empty."
}

if (![string]::IsNullOrWhiteSpace($SQLPackageDeployProperties)) {
    try {
        $sqlPackagePropertyCollection = ConvertFrom-Json $SQLPackageDeployProperties
        Write-Host "Parsed SQLPackageDeployProperties successfully."
    } catch {
        Write-Warning "Failed to parse SQLPackageDeployProperties. Skipping."
    }
} else {
    Write-Host "SQLPackageDeployProperties is empty."
}

# Initialize parameters
$params = @()

switch ($Action.ToLower()) {
    "extract" {
        if (-not $OutputPath) { throw "OutputPath is required for Extract" }
        $params += "/Action:Extract"
        $params += "/TargetFile:$OutputPath"
        $params += "/SourceConnectionString:$ConnectionString"
    }
    "deployreport" {
        if (-not $OutputPath -or -not $DacpacPath) { throw "OutputPath and DacpacPath required for DeployReport" }
        $params += "/Action:DeployReport"
        $params += "/SourceFile:$DacpacPath"
        $params += "/TargetConnectionString:$ConnectionString"
        $params += "/OutputPath:$OutputPath"
        if ($PublishProfilePath) { $params += "/Profile:$PublishProfilePath" }
    }
    "script" {
        if (-not $OutputPath -or -not $DacpacPath) { throw "OutputPath and DacpacPath required for Script" }
        $params += "/Action:Script"
        $params += "/SourceFile:$DacpacPath"
        $params += "/TargetConnectionString:$ConnectionString"
        $params += "/OutputPath:$OutputPath"
        if ($PublishProfilePath) { $params += "/Profile:$PublishProfilePath" }
    }
    "publish" {
        if (-not $DacpacPath) { throw "DacpacPath required for Publish" }
        $params += "/Action:Publish"
        $params += "/SourceFile:$DacpacPath"
        $params += "/TargetConnectionString:$ConnectionString"
        if ($PublishProfilePath) { $params += "/Profile:$PublishProfilePath" }
    }
    default { throw "Unsupported Action: $Action" }
}

# Add parsed SQLCMD variables, parameters, and properties
$params += Format-SqlCmdVariables -SqlCmdVariables $sqlCmdVariableCollection
$params += Format-SqlPackageParameters -SqlPackageParameters $sqlPackageParameterCollection
$params += Format-SqlPackageProperties -SqlPackageProperties $sqlPackagePropertyCollection

# Final command output
Write-Host ""
Write-Host "Running sqlpackage.exe with parameters: $($params -join ' ')"
Write-Host ""

# Retry Logic
$maxRetries = 3
$retryDelaySeconds = 5
$attempt = 1
$success = $false

while ($attempt -le $maxRetries -and -not $success) {
    Write-Host "Attempt ${attempt} of ${maxRetries}: Running sqlpackage.exe..."

    try {
        & $SqlPackagePath @params

        if ($LASTEXITCODE -eq 0) {
            $success = $true
            Write-Host "sqlpackage executed successfully on attempt $attempt"
        } else {
            throw "sqlpackage failed with exit code $LASTEXITCODE"
        }
    } catch {
        Write-Warning "sqlpackage failed on attempt ${attempt}: $_"
        if ($attempt -lt $maxRetries) {
            Write-Host "Retrying in $retryDelaySeconds seconds..."
            Start-Sleep -Seconds $retryDelaySeconds
        } else {
            throw "sqlpackage failed after $maxRetries attempts."
        }
    }
    $attempt++
}

Write-Host "Completed successfully."

=========================================

name: 'Build Output Path and Run DACPAC Deployment Script'
description: 'Uses sqlpackage.exe to perform DACPAC actions: DeployReport, Script, Extract, Publish.'

inputs:
  ArtifactDownloadPath:
    description: 'Path to store the generated artifacts (like deploy reports, scripts).'
    required: true
  DatabaseName:
    description: 'The name of the target database.'
    required: true
  ReleaseNumber:
    description: 'The release number for the deployment.'
    required: true
  FileName:
    description: 'Output file name for generated reports or scripts.'
    required: true
  TargetServer:
    description: 'Target server where DACPAC will be deployed.'
    required: true
  Action:
    description: 'The sqlpackage.exe action to perform (extract, deployreport, script, publish).'
    required: true
  PublishProfileFilePath:
    description: 'Full path to the Publish Profile XML file.'
    required: true
  GithubActor:
    description: 'GitHub actor who triggered the workflow.'
    required: true
  SQLPackageDeployProperties:
    description: 'JSON string of sqlpackage.exe properties (e.g., {"PropertyName":"Value"}).'
    required: true
  SQLCMDVariables:
    description: 'JSON string of SQLCMD variables (e.g., {"VariableName":"Value"}).'
    required: true
  SQLPackageParameters:
    description: 'JSON string of sqlpackage.exe parameters (e.g., {"ParameterName":"Value"}).'
    required: true
  SqlPackagePath:
    description: 'Path to sqlpackage.exe binary.'
    required: true
  DacpacPath:
    description: 'Path to the .dacpac file (optional for Extract action).'
    required: false
  UserName:
    description: 'SQL authentication username.'
    required: true

runs:
  using: "composite"
  steps:
    - name: Run DACPAC Deployment
      shell: powershell
      env:
        ArtifactDownloadPath: ${{ inputs.ArtifactDownloadPath }}
        DatabaseName: ${{ inputs.DatabaseName }}
        ReleaseNumber: ${{ inputs.ReleaseNumber }}
        FileName: ${{ inputs.FileName }}
        TargetServer: ${{ inputs.TargetServer }}
        Action: ${{ inputs.Action }}
        PublishProfileFilePath: ${{ inputs.PublishProfileFilePath }}
        GithubActor: ${{ inputs.GithubActor }}
        SQLPackageDeployProperties: ${{ inputs.SQLPackageDeployProperties }}
        SQLCMDVariables: ${{ inputs.SQLCMDVariables }}
        SQLPackageParameters: ${{ inputs.SQLPackageParameters }}
        SqlPackagePath: ${{ inputs.SqlPackagePath }}
        DacpacPath: ${{ inputs.DacpacPath }}
        UserName: ${{ inputs.UserName }}
      run: |
        $ErrorActionPreference = "Stop"

        Write-Host "Preparing environment for Action: $env:Action"

        # Handle Output Path
        $OutputFilePath = ""
        if ($env:Action -in @('DeployReport', 'Script')) {
            $outputDir = Join-Path $env:ArtifactDownloadPath "deployreports"
            if (-not (Test-Path $outputDir)) {
                New-Item -Path $outputDir -ItemType Directory -Force | Out-Null
            }
            $sanitizedTargetServer = $env:TargetServer.TrimEnd('.')
            $outputFile = "$($sanitizedTargetServer).$($env:DatabaseName).$($env:ReleaseNumber).$($env:FileName)"
            $OutputFilePath = Join-Path $outputDir $outputFile
            Write-Host "Calculated OutputPath: $OutputFilePath"
        }

        # Update Publish Profile DBVersion (for DeployReport and Script actions)
        if ($env:Action -in @('DeployReport', 'Script')) {
          $publishProfilePath = $env:PublishProfileFilePath
          [xml]$xml = Get-Content $publishProfilePath
          $xml.Project.ItemGroup.SqlCmdVariable | Where-Object { $_.Include -eq "DBVersion" } | ForEach-Object {
              $_.Value = "$env:ReleaseNumber - GitHub Actions by $env:GithubActor"
          }
          $xml.Save($publishProfilePath)
          Write-Host "Updated DBVersion in PublishProfile."
        }

        # Call the sqlpackage-runner script
        & $env:GITHUB_WORKSPACE\od-gha-files\sqlpackage-runner-fixed.ps1 `
            -Action $env:Action `
            -DacpacPath $env:DacpacPath `
            -OutputPath $OutputFilePath `
            -ServerInstance $env:TargetServer `
            -DatabaseName $env:DatabaseName `
            -UserName $env:UserName `
            -Password $env:retrievedPassword `
            -SqlPackagePath $env:SqlPackagePath `
            -PublishProfilePath $env:PublishProfileFilePath `
            -UseMultiSubnetFailover "true" `
            -SQLPackageDeployProperties $env:SQLPackageDeployProperties `
            -SQLCmdVariables $env:SQLCMDVariables `
            -SQLPackageParameters $env:SQLPackageParameters
