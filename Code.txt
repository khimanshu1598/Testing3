# od-gha-files/sqlpackage-runner-fixed.ps1

param (
    [string]$Action,
    [string]$DacpacPath,
    [string]$PublishProfilePath = "",
    [string]$ServerInstance,
    [string]$DatabaseName,
    [string]$UserName,
    [string]$Password,
    [string]$SqlPackagePath,
    [string]$OutputPath = "",
    [string]$UseMultiSubnetFailover,
    [string]$SQLPackageDeployProperties,
    [string]$SQLCmdVariables = "",
    [string]$SQLPackageParameters = ""
)

$ErrorActionPreference = "Stop"

Write-Host "Script started. Action: $Action"

# Validate sqlpackage.exe
if (-not (Test-Path $SqlPackagePath)) {
    throw "sqlpackage.exe not found at: $SqlPackagePath"
}

# Ensure output folder exists
if ($OutputPath -ne "") {
    $folder = Split-Path -Path $OutputPath -Parent
    if (-not (Test-Path $folder)) {
        Write-Host "Creating output directory: $folder"
        New-Item -Path $folder -ItemType Directory -Force | Out-Null
    }
}

# Build connection string
$ConnectionString = "Server=$ServerInstance;Database=$DatabaseName;User=$UserName;Password=$Password;Encrypt=True;TrustServerCertificate=True;"
if ($UseMultiSubnetFailover) { $ConnectionString += "multisubnetfailover=true;" }

# Helper functions
function Format-SqlCmdVariables {
    param (
        [AllowNull()][Parameter(Mandatory=$true)][hashtable]$SqlCmdVariables
    )
    $result = @()
    if ($SqlCmdVariables -ne $null) {
        foreach ($variable in $SqlCmdVariables.GetEnumerator()) {
            $result += "/v:$($variable.Name)=$($variable.Value)"
        }
    }
    return $result
}

function Format-SqlPackageParameters {
    param (
        [AllowNull()][Parameter(Mandatory=$true)][hashtable]$Parameters
    )
    $result = @()
    if ($Parameters -ne $null) {
        foreach ($variable in $Parameters.GetEnumerator()) {
            if (($variable.Value -is [int]) -or ($variable.Value -is [bool])) {
                $result += "/$($variable.Name):$($variable.Value)"
            } else {
                $result += "/$($variable.Name):'$($variable.Value)'"
            }
        }
    }
    return $result
}

function Format-SqlPackageProperties {
    param (
        [AllowNull()][Parameter(Mandatory=$true)][hashtable]$Properties
    )
    $result = @()
    if ($Properties -ne $null) {
        foreach ($variable in $Properties.GetEnumerator()) {
            if (($variable.Value -is [int]) -or ($variable.Value -is [bool])) {
                $result += "/p:$($variable.Name)=$($variable.Value)"
            } else {
                $result += "/p:$($variable.Name)='$($variable.Value)'"
            }
        }
    }
    return $result
}

# Parse JSON inputs into hashtables
$sqlCmdVariableCollection = @{}
$sqlPackageParameterCollection = @{}
$sqlPackagePropertyCollection = @{}

if (![string]::IsNullOrWhiteSpace($SQLCmdVariables)) {
    try {
        $parsed = ConvertFrom-Json $SQLCmdVariables
        foreach ($prop in $parsed.PSObject.Properties) {
            $sqlCmdVariableCollection[$prop.Name] = $prop.Value
        }
        Write-Host "Parsed SqlCmdVariables successfully."
    } catch {
        Write-Warning "Failed to parse SqlCmdVariables. Skipping."
    }
} else {
    Write-Host "SqlCmdVariables is empty."
}

if (![string]::IsNullOrWhiteSpace($SQLPackageParameters)) {
    try {
        $parsed = ConvertFrom-Json $SQLPackageParameters
        foreach ($prop in $parsed.PSObject.Properties) {
            $sqlPackageParameterCollection[$prop.Name] = $prop.Value
        }
        Write-Host "Parsed SqlPackageParameters successfully."
    } catch {
        Write-Warning "Failed to parse SqlPackageParameters. Skipping."
    }
} else {
    Write-Host "SqlPackageParameters is empty."
}

if (![string]::IsNullOrWhiteSpace($SQLPackageDeployProperties)) {
    try {
        $parsed = ConvertFrom-Json $SQLPackageDeployProperties
        foreach ($prop in $parsed.PSObject.Properties) {
            $sqlPackagePropertyCollection[$prop.Name] = $prop.Value
        }
        Write-Host "Parsed SQLPackageDeployProperties successfully."
    } catch {
        Write-Warning "Failed to parse SQLPackageDeployProperties. Skipping."
    }
} else {
    Write-Host "SQLPackageDeployProperties is empty."
}

# Initialize params
$params = @()

switch ($Action.ToLower()) {
    "extract" {
        if (-not $OutputPath) { throw "OutputPath is required for Extract" }
        $params += "/Action:Extract", "/TargetFile:$OutputPath", "/SourceConnectionString:$ConnectionString"
        $params += Format-SqlPackageProperties -Properties $sqlPackagePropertyCollection
    }
    "deployreport" {
        if (-not $OutputPath -or -not $DacpacPath) { throw "OutputPath and DacpacPath required for DeployReport" }
        $params += "/Action:DeployReport", "/SourceFile:$DacpacPath", "/TargetConnectionString:$ConnectionString", "/OutputPath:$OutputPath"
        if ($PublishProfilePath) { $params += "/Profile:$PublishProfilePath" }
        $params += Format-SqlCmdVariables -SqlCmdVariables $sqlCmdVariableCollection
        $params += Format-SqlPackageParameters -Parameters $sqlPackageParameterCollection
        $params += Format-SqlPackageProperties -Properties $sqlPackagePropertyCollection
    }
    "script" {
        if (-not $OutputPath -or -not $DacpacPath) { throw "OutputPath and DacpacPath required for Script" }
        $params += "/Action:Script", "/SourceFile:$DacpacPath", "/TargetConnectionString:$ConnectionString", "/OutputPath:$OutputPath"
        if ($PublishProfilePath) { $params += "/Profile:$PublishProfilePath" }
        $params += Format-SqlCmdVariables -SqlCmdVariables $sqlCmdVariableCollection
        $params += Format-SqlPackageParameters -Parameters $sqlPackageParameterCollection
        $params += Format-SqlPackageProperties -Properties $sqlPackagePropertyCollection
    }
    "publish" {
        if (-not $DacpacPath) { throw "DacpacPath required for Publish" }
        $params += "/Action:Publish", "/SourceFile:$DacpacPath", "/TargetConnectionString:$ConnectionString"
        if ($PublishProfilePath) { $params += "/Profile:$PublishProfilePath" }
        $params += Format-SqlCmdVariables -SqlCmdVariables $sqlCmdVariableCollection
        $params += Format-SqlPackageParameters -Parameters $sqlPackageParameterCollection
        $params += Format-SqlPackageProperties -Properties $sqlPackagePropertyCollection
    }
    default { throw "Unsupported Action: $Action" }
}

# Execute
Write-Host "Running sqlpackage.exe with parameters: $($params -join ' ')"

$maxRetries = 3
$retryDelaySeconds = 5
$attempt = 1
$success = $false

while ($attempt -le $maxRetries -and -not $success) {
    Write-Host "Attempt ${attempt} of ${maxRetries}: Running sqlpackage.exe..."
    try {
        & $SqlPackagePath @params
        if ($LASTEXITCODE -eq 0) {
            $success = $true
            Write-Host "sqlpackage executed successfully on attempt $attempt"
        } else {
            throw "sqlpackage failed with exit code $LASTEXITCODE"
        }
    } catch {
        Write-Warning "sqlpackage failed on attempt ${attempt}: $_"
        if ($attempt -lt $maxRetries) {
            Write-Host "Retrying in $retryDelaySeconds seconds..."
            Start-Sleep -Seconds $retryDelaySeconds
        } else {
            throw "sqlpackage failed after $maxRetries attempts."
        }
    }
    $attempt++
}

Write-Host "Completed successfully"



==============

name: 'Build Output path and Run the DACPAC Deployment script'
description: 'Using sqlpackage.exe to run DACPAC operations - DeployReport, Script, Extract, Publish'

inputs:
  ArtifactDownloadPath:
    description: 'Path where the artifacts will be stored'
    required: true
  DatabaseName:
    description: 'The database name the DACPAC is being applied against'
    required: true
  ReleaseNumber:
    description: 'Release number of the build'
    required: true
  FileName:
    description: 'The name of the output file'
    required: true
  targetServer:
    description: 'The host to deploy the DACPAC to'
    required: true
  Action:
    description: 'The sqlpackage.exe action to execute: DeployReport, Script, Extract, Publish'
    required: true
  PublishProfileFilePath:
    description: 'The fully qualified path of the Publish Profile to use'
    required: true
  GithubActor:
    description: 'GitHub Actor triggering the build'
    required: true
  SQLPackageDeployProperties:
    description: 'JSON string for SQLPackage properties. Example: {"PropertyName":"Value"}'
    required: true
  SQLCMDVariables:
    description: 'JSON string for SQLCMD variables. Example: {"VariableName":"Value"}'
    required: true
  SQLPackageParameters:
    description: 'JSON string for SQLPackage parameters. Example: {"ParameterName":"Value"}'
    required: true
  SqlPackagePath:
    description: 'Full path to sqlpackage.exe'
    required: true
  DacpacPath:
    description: 'Full path to the DACPAC file'
    required: false
  UserName:
    description: 'SQL username to authenticate'
    required: true

runs:
  using: composite
  steps:
    - name: Build output path and run DACPAC deployment script
      shell: powershell
      env:
        ArtifactDownloadPath: ${{ inputs.ArtifactDownloadPath }}
        DatabaseName: ${{ inputs.DatabaseName }}
        ReleaseNumber: ${{ inputs.ReleaseNumber }}
        FileName: ${{ inputs.FileName }}
        targetServer: ${{ inputs.targetServer }}
        Action: ${{ inputs.Action }}
        PublishProfileFilePath: ${{ inputs.PublishProfileFilePath }}
        GithubActor: ${{ inputs.GithubActor }}
        SQLPackageDeployProperties: ${{ inputs.SQLPackageDeployProperties }}
        SQLCMDVariables: ${{ inputs.SQLCMDVariables }}
        SQLPackageParameters: ${{ inputs.SQLPackageParameters }}
      run: |
        $ErrorActionPreference = "Stop"

        # Replace Octopus variable if exists
        $SQLCMDVariablesUpdated = $env:SQLCMDVariables -replace '#{Octopus.Release.Number}', $env:ReleaseNumber

        function Format-JsonAsHashtable {
          param([string]$JsonString)
          if ([string]::IsNullOrWhiteSpace($JsonString)) {
            return @{}
          }
          try {
            return ($JsonString | ConvertFrom-Json -AsHashtable)
          } catch {
            Write-Host "Warning: Failed to parse JSON. Returning empty hashtable."
            return @{}
          }
        }

        $parsedSqlPackageDeployProperties = Format-JsonAsHashtable -JsonString $env:SQLPackageDeployProperties
        $parsedSqlCMDVariables = Format-JsonAsHashtable -JsonString $SQLCMDVariablesUpdated
        $parsedSqlPackageParameters = Format-JsonAsHashtable -JsonString $env:SQLPackageParameters

        $matrixJson = "$env:MATRIX_INSTANCE_LIST"
        if (-not ($matrixJson.Trim().StartsWith('['))) {
          $matrixJson = @($matrixJson | ConvertFrom-Json) | ConvertTo-Json -Compress
        }

        Write-Host "MATRIX_INSTANCE_LIST: $matrixJson"
        $parsedMatrix = $matrixJson | ConvertFrom-Json
        $allOutputPaths = ""

        foreach ($item in $parsedMatrix) {
          $instance = $item.instance
          $dbServer = $item.dbServerName
          $role = $item.role
          Write-Host ("Running Action: {0}, Instance: {1}, Role: {2}, DB Server: {3}" -f $env:Action, $instance, $role, $dbServer)

          $OutputFilePath = ""
          if ($env:Action -in @("DeployReport", "Script")) {
            $OutputFolder = Join-Path $env:ArtifactDownloadPath "deployreports"
            $OutputFileName = "$($env:DatabaseName).$($env:ReleaseNumber).$role.$($env:FileName)"
            $OutputFilePath = Join-Path $OutputFolder $OutputFileName

            $outputFileNameOnly = Split-Path $OutputFilePath -Leaf
            $outputDirectoryOnly = Split-Path $OutputFilePath -Parent

            $sanitizedTargetServer = $env:targetServer.TrimEnd('.')
            $outputFileNameOnlyWithDB = $outputFileNameOnly.Replace('[DatabaseName]', $env:DatabaseName).TrimStart('.')
            $OutputFilePath = Join-Path $outputDirectoryOnly "$sanitizedTargetServer.$outputFileNameOnlyWithDB"

            if (!(Test-Path (Split-Path $OutputFilePath))) {
              New-Item -ItemType Directory -Path (Split-Path $OutputFilePath) -Force
            }
            $allOutputPaths += "$OutputFilePath,"
          }

          # Update DBVersion inside Publish Profile
          $xml = [xml](Get-Content $env:PublishProfileFilePath)
          $xml.Project.ItemGroup.SqlCmdVariable | Where-Object { $_.Include -eq 'DBVersion' } | ForEach-Object {
            $_.Value = "$env:RELEASE_NUMBER - GitHub Actions by $env:GITHUB_ACTOR ($env:GITHUB_ACTOR)"
          }
          $xml.Save($env:PublishProfileFilePath)

          # Call main sqlpackage-runner script
          & $env:scriptPath `
            -Action $env:Action `
            -DacpacPath "${{ inputs.DacpacPath }}" `
            -OutputPath "$OutputFilePath" `
            -ServerInstance "$dbServer" `
            -DatabaseName "${{ inputs.DatabaseName }}" `
            -UserName "${{ inputs.UserName }}" `
            -Password $env:retrievedPassword `
            -SqlPackagePath "${{ inputs.SqlPackagePath }}" `
            -PublishProfilePath "${{ inputs.PublishProfileFilePath }}" `
            -UseMultiSubnetFailover "${{ inputs.UseMultiSubnetFailover }}" `
            -SQLPackageDeployProperties ($parsedSqlPackageDeployProperties | ConvertTo-Json -Compress) `
            -SQLCmdVariables ($parsedSqlCMDVariables | ConvertTo-Json -Compress) `
            -SQLPackageParameters ($parsedSqlPackageParameters | ConvertTo-Json -Compress)
        }

        if ($env:Action -in @("DeployReport", "Script")) {
          $allOutputPaths = $allOutputPaths.TrimEnd(',')
          "OutPutPath=$allOutputPaths" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        }
