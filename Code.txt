Refreshing environment variables from the registry for powershell.exe. Please wait...
Finished
Get-Item : Cannot find path 'Env:\ArtifactDownloadPath' because it does not exist.
At C:\actions-runner\_work\_temp\8b7cc68d-8972-40be-9c80-e8f4abaf5c2d.ps1:19 char:13
+   if (-not (Get-Item -Path "env:${input}")) {
+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (Env:\ArtifactDownloadPath:String) [Get-Item], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand


#####################################

name: 'Build Output path and Run the DACPAC Deployment script'
description: 'Uses sqlpackage.exe to run DACPAC operations like DeployReport, Script, Extract, and Publish.'

inputs:
  ArtifactDownloadPath:
    description: 'Path where the Artifacts will be stored'
    required: true
  DatabaseName:
    description: 'The database name the DACPAC is being applied against'
    required: true
  ReleaseNumber:
    description: 'Release Number of the build'
    required: true
  FileName:
    description: 'The name of Output File'
    required: true
  targetServer:
    description: 'The host to deploy the DACPAC to'
    required: true
  Action:
    description: 'The action to have sqlpackage.exe execute. One of: extract, deployreport, script, publish'
    required: true
  PublishProfileFilePath:
    description: 'The fully qualified path and file name of the Publish Profile to be applied against the supplied DACPAC'
    required: true
  GithubActor:
    description: 'Returns the username of the person or app that triggered the workflow run.'
    required: true
  SQLPackageDeployProperties:
    description: 'Collection of SQLPackage.exe Properties in JSON format'
    required: true
  SQLCMDVariables:
    description: 'Collection of SQLCMD Variables in JSON format'
    required: true
  SQLPackageParameters:
    description: 'Collection of SQLPackage.exe Parameters in JSON format'
    required: true
  SqlPackagePath:
    description: 'Path to sqlpackage.exe'
    required: true
  DacpacPath:
    description: '[Optional] Fully qualified path to the DACPAC to publish.'
    required: false
  UserName:
    description: 'SQL username to be used for performing actions'
    required: true
  UseMultiSubnetFailover:
    description: 'Add MultiSubnetFailover=True to the connection string'
    required: true

runs:
  using: composite
  steps:
    - name: Validate Required Inputs
      shell: powershell
      run: |
        $requiredInputs = @(
          'ArtifactDownloadPath',
          'DatabaseName',
          'ReleaseNumber',
          'FileName',
          'targetServer',
          'Action',
          'PublishProfileFilePath',
          'SQLPackageDeployProperties',
          'SQLCMDVariables',
          'SQLPackageParameters',
          'SqlPackagePath',
          'UserName',
          'UseMultiSubnetFailover'
        )

        foreach ($input in $requiredInputs) {
          if (-not (Get-Item -Path "env:${input}")) {
            Write-Error "‚ùå Required input '$input' not provided."
            exit 1
          }
        }

    - name: Build Output path and Run the DACPAC Deployment script
      shell: powershell
      env:
        ArtifactDownloadPath: ${{ inputs.ArtifactDownloadPath }}
        DatabaseName: ${{ inputs.DatabaseName }}
        ReleaseNumber: ${{ inputs.ReleaseNumber }}
        FileName: ${{ inputs.FileName }}
        targetServer: ${{ inputs.targetServer }}
        Action: ${{ inputs.Action }}
        PublishProfileFilePath: ${{ inputs.PublishProfileFilePath }}
        GithubActor: ${{ inputs.GithubActor }}
        SQLPackageDeployProperties: ${{ inputs.SQLPackageDeployProperties }}
        SQLCMDVariables: ${{ inputs.SQLCMDVariables }}
        SQLPackageParameters: ${{ inputs.SQLPackageParameters }}
        UseMultiSubnetFailover: ${{ inputs.UseMultiSubnetFailover }}
        SqlPackagePath: ${{ inputs.SqlPackagePath }}
        DacpacPath: ${{ inputs.DacpacPath }}
        UserName: ${{ inputs.UserName }}
      run: |
        function Format-JsonAsKeyValue {
            param ([string]$jsonString)
            if ([string]::IsNullOrWhiteSpace($jsonString)) { return "" }
            try {
              $json = $jsonString | ConvertFrom-Json
              if (-not $json) { return "" }
            } catch {
              Write-Host "‚ö†Ô∏è Invalid JSON format."
              return ""
            }
            return ($json.psobject.Properties | ForEach-Object { "$($_.Name)=$($_.Value)" }) -join ","
        }

        $SQLCMDVariablesUpdated = $env:SQLCMDVariables -replace '#{Octopus.Release.Number}', $env:ReleaseNumber
        $DeployProps = Format-JsonAsKeyValue $env:SQLPackageDeployProperties
        $CMDVars = Format-JsonAsKeyValue $SQLCMDVariablesUpdated
        $Params = Format-JsonAsKeyValue $env:SQLPackageParameters

        $matrixJson = "$env:MATRIX_INSTANCE_LIST"
        if (-not $matrixJson.StartsWith('[')) {
          $matrixJson = @($matrixJson | ConvertFrom-Json) | ConvertTo-Json -Compress
        }
        $parsedMatrix = $matrixJson | ConvertFrom-Json
        $allOutputPaths = ""

        foreach ($item in $parsedMatrix) {
            $instance = $item.instance
            $dbServer = $item.dbServerName
            $role = $item.role

            Write-Host "üîÅ Running action $($env:Action) for Instance: $instance, Role: $role, DB Server: $dbServer"

            $OutputFilePath = ""
            if ($env:Action -in @("DeployReport", "Script")) {
                $OutputFolder = Join-Path $env:ArtifactDownloadPath "deployreports"
                $OutputFileName = "$($env:DatabaseName).$($env:ReleaseNumber).$role.$($env:FileName)"
                $OutputFilePath = Join-Path $OutputFolder $OutputFileName

                $outputFileNameOnly = Split-Path $OutputFilePath -Leaf
                $outputDirectoryOnly = Split-Path $OutputFilePath -Parent

                $sanitizedTargetServer = $env:targetServer.TrimEnd('.')
                $outputFileNameOnlyWithDB = $outputFileNameOnly.Replace('[DatabaseName]', $env:DatabaseName).TrimStart('.')
                $OutputFilePath = Join-Path $outputDirectoryOnly "$sanitizedTargetServer.$outputFileNameOnlyWithDB"

                if (!(Test-Path (Split-Path $OutputFilePath))) {
                    New-Item -ItemType Directory -Path (Split-Path $OutputFilePath) -Force
                }
                $allOutputPaths += "$OutputFilePath,"
            }

            & $env:scriptPath `
              -Action "$env:Action" `
              -DacpacPath "$env:DacpacPath" `
              -OutputPath "$OutputFilePath" `
              -ServerInstance "$dbServer" `
              -DatabaseName "$env:DatabaseName" `
              -UserName "$env:UserName" `
              -Password $env:retrievedPassword `
              -SqlPackagePath "$env:SqlPackagePath" `
              -PublishProfilePath "$env:PublishProfileFilePath" `
              -UseMultiSubnetFailover "$env:UseMultiSubnetFailover" `
              -SQLPackageDeployProperties "$DeployProps" `
              -SQLCmdVariables "$CMDVars" `
              -SQLPackageParameters "$Params"
        }

        if ($env:Action -in @("DeployReport", "Script")) {
            $allOutputPaths = $allOutputPaths.TrimEnd(',')
            "OutPutPath=$allOutputPaths" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        }
