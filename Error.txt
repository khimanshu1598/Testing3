paassql-pipelines/invoke-sql-actions/action.yaml: -

name: 'Invoke sql_actions.ps1 on remote/target server.'
description: 'Using aws ssm to invoke the script based on passed parameters.'

inputs:
  sql-password-parameter-store:
    description: 'Name of the system manager parameter store which contains password for sql user'
    required: true
  db-name:
    description: 'Name of the DB'
    required: true
  sql-user-name:
    description: 'Name of the sql user to be created'
    required: true
  sql-activity:
    description: 'Activity to perform [create-user, validate-delete-user, delete-user ]'
    required: true
  destination-path:
    description: 'Path on the target server where script needs to be added'
    required: true
  aws-region:
    description: 'AWS region details'
    required: true
  username:
    description: 'Username of impersonated user in domainName\username format'
    required: true
  needs-windows-authentication:
    description: 'Boolean value to impersonate the user using Windows Authentication or SQL Server Authentication'
    required: true
    default: true

runs:
  using: composite
  steps:
  - name: Invoke sql actions script on EC2 via SSM
    shell: bash
    run: |
      #Fetch sql-user password from parameter store
      sqlPassword=$(aws ssm get-parameter \
      --name ${{ inputs.sql-password-parameter-store }} \
      --with-decryption \
      --query "Parameter.Value" \
      --output text)

      matrixJson="$MATRIX_INSTANCE_LIST"
      if [[ "$matrixJson" != \[* ]]; then
        # echo "Wrapping single JSON object in an array..."
        matrixJson=$(echo "$matrixJson" | jq -c '[.]')
      fi
      # echo "Raw MATRIX_INSTANCE_LIST: $matrixJson"


      echo "$matrixJson" | jq -c '.[]' | while read -r item; do
        instance=$(echo "$item" | jq -r '.instance')
        dbServer=$(echo "$item" | jq -r '.dbServerName')
        role=$(echo "$item" | jq -r '.role')

        echo "----------------------------------"
        echo "Sending to - Instance: $instance, Role: $role, DB Server: $dbServer for ${{ inputs.sql-activity }}"

        #Input parameters required to run sql-actions.ps1
        serverInstance=$dbServer
        databaseName=${{ inputs.db-name }}
        sqlUserName=${{ inputs.sql-user-name }}
        sqlPassword=$sqlPassword
        adUserSsmPassword='/secure/dbpassword'
        sqlActivity=${{ inputs.sql-activity }}
        username=${{ inputs.username }}
        needsWindowsAuthentication=${{ inputs.needs-windows-authentication }}

        echo "Database Name is $databaseName"

        # PowerShell command to invoke the script directly from the remote server
        PS_COMMAND="powershell -File "${{ inputs.destination-path }}\\sql-actions.ps1" -serverInstance '$serverInstance' -databaseName '$databaseName' -sqlUserName '$sqlUserName' -sqlPassword '$sqlPassword' -adUserSsmPassword '$adUserSsmPassword' -username '$username' -sqlActivity '$sqlActivity' -needsWindowsAuthentication '$needsWindowsAuthentication' -Verbose"

        #Use AWS SSM command to run the above powershell script
        ssmCommand=$(aws ssm send-command \
          --document-name "AWS-RunPowerShellScript" \
          --instance-ids "$instance" \
          --region "${{ inputs.aws-region }}" \
          --comment "Invoking script sql-actions.ps1 on target instance via GitHub Actions for $sqlActivity" \
          --parameters "commands=[\"$PS_COMMAND\"]" \
          --query "Command.CommandId" \
          --output text)

        # Exporting commandId for next steps.
        echo "commandId=$ssmCommand" >> $GITHUB_ENV
      done

  - name: Check command status
    shell: bash
    run: |
      matrixJson="$MATRIX_INSTANCE_LIST"

      if [[ "$matrixJson" != \[* ]]; then
        # echo "Wrapping single JSON object in an array..."
        matrixJson=$(echo "$matrixJson" | jq -c '[.]')
      fi

      # echo "Raw MATRIX_INSTANCE_LIST: $matrixJson"

      mapfile -t matrixItems < <(echo "$matrixJson" | jq -c '.[]')

      for item in "${matrixItems[@]}"; do
        instance=$(echo "$item" | jq -r '.instance')
        dbServer=$(echo "$item" | jq -r '.dbServerName')
        role=$(echo "$item" | jq -r '.role')

        # echo "----------------------------------"
        # echo "Sending to - Instance: $instance, Role: $role, DB Server: $dbServer for ${{ inputs.sql-activity }}"

        echo "Command ID generated: $commandId"

        if [[ -n "$commandId" ]]; then
          echo "SSM command sent successfully!"
          retries=3
          attempt=0
          success=false
          while [[ $attempt -lt $retries && $success == false ]]; do
            # Attempt to wait for the command execution to finish
            echo "Simulating attempt #$((attempt + 1))"
            # Actual command (uncomment for real use):
            if aws ssm wait command-executed \
                --command-id "$commandId" \
                --instance-id "$instance"; then
              success=true
              echo "SSM command executed successfully!"
            else
              echo "SSM command execution failed. Retrying..."
              attempt=$((attempt + 1))
              sleep 5
            fi
          done
          if [[ $success == false ]]; then
            echo "Failed to execute the SSM command after $retries attempts."
            exit 1
          fi
        else
          echo "Failed to send SSM command."
          exit 1
        fi

        commandStatus=$(aws ssm list-command-invocations \
          --command-id "$commandId" \
          --details \
          --output json)

        standardOutput=$(echo "$commandStatus" | jq -r '.CommandInvocations[0].CommandPlugins[0].Output')

        if echo "$standardOutput" | grep -q "ERROR"; then
          echo "Error detected in the command output:"
          echo "$standardOutput"
          exit 1
        else
          echo "No error detected in the command output."
        fi
      done
